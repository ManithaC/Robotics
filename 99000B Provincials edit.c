#pragma config(Sensor, in1,    Pexpander,      sensorAnalog)
#pragma config(Sensor, in2,    GYRO,           sensorGyro)
#pragma config(Sensor, in3,    ,               sensorAnalog)
#pragma config(Sensor, in4,    ,               sensorAnalog)
#pragma config(Sensor, in7,    A,              sensorAnalog)
#pragma config(Sensor, in8,    B,              sensorAnalog)
#pragma config(Sensor, dgtl6,  ,               sensorTouch)
#pragma config(Sensor, dgtl7,  arms_sensor,    sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  right_sensor,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, left_sensor,    sensorQuadEncoder)
#pragma config(Motor,  port1,           L_one,         tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           DR1,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           L_two,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           L_Y,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           Claw1,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Claw2,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           R_Y,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           R_two,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           DL1,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          R_one,         tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

/*
   ___     ___     ___     ___     ___    ____
  / _ \   / _ \   / _ \   / _ \   / _ \  |  _ \
 | (_) | | (_) | | | | | | | | | | | | | | |_) |
  \__, |  \__, | | | | | | | | | | | | | |  _ <
    / /     / /  | |_| | | |_| | | |_| | | |_) |
   /_/     /_/    \___/   \___/   \___/  |____/

*/

//controls

/*
channel 1 and channel 2 - drive
channel 3 - arms
channel 4 - manual claw
button 7U - (hold) enable manual claw
button 6U - claw close
button 6D - claw extra hold
button 5U - claw open
*/




//global integers
#define open 1650
#define close 2650
#define arm_up -900
bool auton_claw;
string mainBattery, batteryTwo;
string side, half = "_";
int choice = 2; // default
string choices[] = {"left_main","fast_main(l)","left_block","right_block","off"};
string auton_disp;
int auton = 0;
int claw;
int x_axis, y_axis;
float a_value = 0.000062;
int lift;
int claw_l, claw_r;
int claw_d_l;
int claw_d_r;
bool hold = false;
float gyro_Kp = 2;
float gyro_Ki = 0.005;
float gyro_Kd = 1.5;
int gyro_tol = 10;
int mode = 0;
int height;


/*
 ___           ________      ________
|\  \         |\   ____\    |\   ___ \
\ \  \        \ \  \___|    \ \  \_|\ \
 \ \  \        \ \  \        \ \  \ \\ \
  \ \  \____    \ \  \____    \ \  \_\\ \
   \ \_______\   \ \_______\   \ \_______\
    \|_______|    \|_______|    \|_______|


*/


void waitForPress(){ 	while(nLCDButtons == 0){}	wait1Msec(5);}

void waitForRelease(){ 	while(nLCDButtons != 0){} wait1Msec(5);}

task auxLCD()
{
	string space = " ";
	string choice_final;

	while(1==1)
	{
		if(choice<0)
		{
			choice = 3;
		}

		sprintf(auton_disp, side, half, choice );
	}
}
task LCD()
{
	startTask (auxLCD);
	bLCDBacklight = 1;
	while(true)
	{
		switch(mode)
		{
		case 0:
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDCenteredString(0,"99000B");
			displayLCDCenteredString(1,"Voltage    Auton");
			waitForPress();
			if(nLCDButtons == 1)
			{
				waitForRelease();
				mode = 1;
			}
			else if(nLCDButtons == 4)
			{
				waitForRelease();
				mode = 2;
			}
			break;

		case 1:
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString(0, 0, "Cortex:");
			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
			displayNextLCDString(mainBattery);
			displayLCDString(1, 0, "Pwr_Exp:");
			sprintf(batteryTwo, "%1.2f%c", SensorValue[Pexpander]/280.0, 'V');    //Build the value to be displayed
			displayNextLCDString(batteryTwo);
			waitForPress();
			if(nLCDButtons > 0)
			{
				waitForRelease();
				mode = 0;
			}
			break;

		case 2:
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDCenteredString(0,choices[choice]);
			displayLCDCenteredString(1,"<     Back     >");
			waitForPress();
			if(nLCDButtons == 1)
			{
				waitForRelease();
				choice = 0;

			}
			else if(nLCDButtons == 2)
			{
				waitForRelease();
				mode = 0;
			}
			else if(nLCDButtons == 4)
			{
				waitForRelease();
				choice++;
				if(choice>4)
				{
					choice = 0;
				}
			}
			break;


		}
	}
}

/*
 ________      ________      ___      ___      ___  _______
|\   ___ \    |\   __  \    |\  \    |\  \    /  /||\  ___ \
\ \  \_|\ \   \ \  \|\  \   \ \  \   \ \  \  /  / /\ \   __/|
 \ \  \ \\ \   \ \   _  _\   \ \  \   \ \  \/  / /  \ \  \_|/__
  \ \  \_\\ \   \ \  \\  \|   \ \  \   \ \    / /    \ \  \_|\ \
   \ \_______\   \ \__\\ _\    \ \__\   \ \__/ /      \ \_______\
    \|_______|    \|__|\|__|    \|__|    \|__|/        \|_______|


*/
task driving()
{
	while(true)
	{
		x_axis = (a_value * (vexRT[Ch1]* vexRT[Ch1]* vexRT[Ch1]));
		y_axis = (a_value * (vexRT[Ch2]* vexRT[Ch2]* vexRT[Ch2]));
		lift = vexRT[Ch3];

		motor[DL1] = (y_axis - x_axis);
		motor[DR1] = (y_axis + x_axis);
		motor[L_one] = lift;
		motor[L_two] = lift;
		motor[L_Y] = lift;
		motor[R_one] = lift;
		motor[R_two] = lift;
		motor[R_Y] = lift;
	}
}
/*

 ________      ___           ________      ___       __
|\   ____\    |\  \         |\   __  \    |\  \     |\  \
\ \  \___|    \ \  \        \ \  \|\  \   \ \  \    \ \  \
 \ \  \        \ \  \        \ \   __  \   \ \  \  __\ \  \
  \ \  \____    \ \  \____    \ \  \ \  \   \ \  \|\__\_\  \
   \ \_______\   \ \_______\   \ \__\ \__\   \ \____________\
    \|_______|    \|_______|    \|__|\|__|    \|____________|


*/

task claw_d()
{
	claw_r = SensorValue[in4] ;
	claw_l = SensorValue[in3] + 100;
	int claw_r_save;
	int claw_l_save;
	while(true)
	{
		claw_r_save = claw_r;
		claw_l_save = claw_l;
		wait1Msec(100);
		claw_d_r = claw_r - claw_r_save;
		claw_d_l = claw_l - claw_l_save;
	}
}

task claw_()
{
	startTask(claw_d);
	while(true)
	{
		claw_r = SensorValue[in4] ;
		claw_l = SensorValue[in3] + 100;
		if(vexRT[Btn5U] == 1)
		{
			claw = open;
		}
		if(vexRT[Btn6U] == 1)
		{
			claw = close;
		}

		if(vexRT[Btn7U] == 0 && vexRT[Btn6D] == 0)
		{
			motor[Claw1] = (claw - claw_r)*0.2 + /*claw_r_i*0.000*/ - claw_d_r*0.04;
			motor[Claw2] = (claw - claw_l)*0.2 + /*claw_r_i*0.000*/  - claw_d_l*0.04;
		}
		else if(auton_claw == true)
		{
			motor[Claw1] = (claw - claw_r)*0.2;
			motor[Claw2] = (claw - claw_l)*0.2;
		}

		else if(vexRT[Btn7U] == 1)
		{
			motor[Claw1] = vexRT[Ch4];
			motor[Claw2] = vexRT[Ch4];
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[Claw1] = 100;
			motor[Claw2] = 100;
		}
	}
}
/*

 ________      ___  ___      _________    ________      ________
|\   __  \    |\  \|\  \    |\___   ___\ |\   __  \    |\   ___  \
\ \  \|\  \   \ \  \\\  \   \|___ \  \_| \ \  \|\  \   \ \  \\ \  \
 \ \   __  \   \ \  \\\  \       \ \  \   \ \  \\\  \   \ \  \\ \  \
  \ \  \ \  \   \ \  \\\  \       \ \  \   \ \  \\\  \   \ \  \\ \  \
   \ \__\ \__\   \ \_______\       \ \__\   \ \_______\   \ \__\\ \__\
    \|__|\|__|    \|_______|        \|__|    \|_______|    \|__| \|__|



*/

void dist(int dist, int speed)
{
	SensorValue[left_sensor] = 0;
	int direction;
	if (dist < 0){direction = -1;}
	else if (dist > 0){direction = 1;}
	while(SensorValue[left_sensor] < dist)
	{
		motor[DL1] = speed*direction;
		motor[DR1] = speed*direction;
	}
	motor[DL1] = (speed*-direction)/9;
	motor[DR1] = (speed*-direction)/9;
	wait1Msec(250);
	motor[DL1] = 0;
	motor[DR1] = 0;
}
void time_d(int time, int speed)
{
	SensorValue[left_sensor] = 0;
	int direction;
	if (time < 0){direction = -1;}
	else if (time > 0){direction = 1;}
	clearTimer(T4);
	while(time1[T4] < abs(time))
	{
		motor[DL1] = speed*direction;
		motor[DR1] = speed*direction;
	}
	motor[DL1] = (speed*-direction)/9;
	motor[DR1] = (speed*-direction)/9;
	wait1Msec(250);
	motor[DL1] = 0;
	motor[DR1] = 0;
}

void TurnDegree(int degrees, int speed)
{
	int left = 0, right = 0;
	SensorValue[GYRO] = 0;
	if (degrees < 0){left = -1; right = 1;}
	else if (degrees > 0){left = 1; right = -1; }
	float ticks = abs(degrees*6.7);
	clearTimer(T3);

	while(abs(SensorValue[GYRO]) < ticks)
	{

		motor[DL1] = speed*left;
		motor[DR1] = speed*right;

	}
	motor[DL1] = (speed*left*-1)/9;
	motor[DR1] = (speed*right*-1)/9;

	wait1Msec(250);
	motor[DL1] = 0;
	motor[DR1] = 0;
}
task arms_PI()
{
	int counter = 0;
	int Lift_P = 0;
	int Lift_I = 0;
	SensorValue[arms_sensor] = 0;
	while(true)
	{

		while(hold == true)
		{
			//Liftx = (((40 - SensorValue[arms_sensor])*100)/ 40;
			Lift_P = (1.75 * (height - SensorValue[arms_sensor]));

			if(hold == true)
			{
				lift = (20+(Lift_P));
				counter ++;

			}
			if(counter > 500)
			{
				Lift_I += 1;
				counter = 0;
			}
			motor[L_one] = -lift;
			motor[L_two] = -lift;
			motor[L_Y] = -lift;
			motor[R_one] = -lift;
			motor[R_two] = -lift;
			motor[R_Y] = -lift;
		}

	}
}
void shoot(int arms, int wait, bool arms_return)
{
	bool arms_up = false;
	bool arms_done = false;

	while(arms_done == false)
	{


		if(SensorValue[arms_sensor] > arms && arms_up == false)
		{
			motor[L_one] = 127;
			motor[L_two] = 127;
			motor[L_Y] = 127;
			motor[R_one] = 127;
			motor[R_two] = 127;
			motor[R_Y] = 127;

		}
		else if(SensorValue[arms_sensor] < arms && arms_up == false)
		{

			motor[L_one] = 1;
			motor[L_two] = 1;
			motor[L_Y] = 1;
			motor[R_one] = 1;
			motor[R_two] = 1;
			motor[R_Y] = 1;
			wait10Msec(wait);
			claw = open;
			wait10Msec(50);
			claw = close;
			wait10Msec(wait);
			arms_up = true;


		}
		else if(arms_up == true)
		{

		}
		if(arms_return == true && arms_up == true)
		{
			if(SensorValue[arms_sensor] < -20 )
			{
				motor[L_one] = -100;
				motor[L_two] = -100;
				motor[L_Y] = -100;
				motor[R_one] = -100;
				motor[R_two] = -100;
				motor[R_Y] = -100;
			}
			else
			{
				motor[L_one] = 0;
				motor[L_two] = 0;
				motor[L_Y] = 0;
				motor[R_one] = 0;
				motor[R_two] = 0;
				motor[R_Y] = 0;
				arms_done = true;
			}
		}
		else if(arms_up == true && arms_return == false)
		{
			motor[L_one] = 0;
			motor[L_two] = 0;
			motor[L_Y] = 0;
			motor[R_one] = 0;
			motor[R_two] = 0;
			motor[R_Y] = 0;
			arms_done = true;
		}


	}
}

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	startTask(LCD);
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{

		//startTask(arms_PI);
		auton_claw = true;

	while(choice == 0)
	{
		dist(350, 127);
		claw = open;
		TurnDegree(-57,127);
		dist(750,127);
		claw = close;
		dist(150,127);
		hold = true;
		height = -400;
		TurnDegree(-130, 127);
		time_d(-700,127);
		hold = false;
		shoot(arm_up,5,true);
		claw = open;
		time_d(1450,127);
		claw = close;
		wait10Msec(80);
		hold = true;
		height = -400;
		time_d(-1400,127);
		hold = false;
		shoot(arm_up,5,true);
		claw = open;
		TurnDegree(15,127);
		time_d(1300,127);
		claw = close;
		hold = true;
		height = -400;
		time_d(-1000,127);
		hold = false;
		shoot(arm_up,5,true);
	}
	while(choice == 1)
	{
		startTask(claw_);
		dist(950,127);
		claw = close;
		dist(150,127);
		hold = true;
		height = -400;
		TurnDegree(-110, 127);
		time_d(-700,127);
		hold = false;
		shoot(arm_up,5,true);
		claw = open;
		time_d(1450,127);
		claw = close;
		wait10Msec(80);
		hold = true;
		height = -400;
		time_d(-1400,127);
		hold = false;
		shoot(arm_up,5,true);
		claw = open;
		TurnDegree(15,127);
		time_d(1300,127);
		claw = close;
		hold = true;
		height = -400;
		time_d(-1000,127);
		hold = false;
		shoot(arm_up,5,true);
	}
	while(choice == 2)
	{
		time_d(-1600,127);
		startTask(claw_);
		claw = open;
		wait10Msec(100);
		stopTask(claw_);
		shoot(arm_up-200,5,true);
		choice = 4;
	}
	while(choice == 4)
	{
		//off
	}




}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	auton_claw = false;
	hold = false;
	startTask(LCD);

	while(true)
	{
		startTask(driving);
		startTask(claw_);
	}
}
